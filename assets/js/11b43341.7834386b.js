"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2256],{15293:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"category","label":"Usage","collapsed":false,"items":[{"type":"link","label":"Getting Started","href":"/docs/","docId":"getting-started","unlisted":false},{"type":"link","label":"Command Line","href":"/docs/tailcall-graphql-cli","docId":"cli","unlisted":false},{"type":"link","label":"Configuration","href":"/docs/tailcall-dsl-graphql-custom-directives","docId":"directives","unlisted":false},{"type":"link","label":"Resolver Context","href":"/docs/graphql-resolver-context-tailcall","docId":"context","unlisted":false},{"type":"link","label":"GraphQL Playground","href":"/docs/graphql-playground-guide","docId":"playground","unlisted":false},{"type":"link","label":"Best Practices","href":"/docs/graphql-best-practices-tailcall","docId":"conventions","unlisted":false},{"type":"link","label":"Sequence vs Parallel","href":"/docs/graphql-data-access-parallel-vs-sequence","docId":"execution-strategy","unlisted":false},{"type":"link","label":"Watch Mode","href":"/docs/graphql-watch-mode-tailcall","docId":"watch-mode","unlisted":false}],"collapsible":true},{"type":"category","label":"Features","collapsed":false,"items":[{"type":"link","label":"N+1 Identification","href":"/docs/graphql-n-plus-one-problem-solved-tailcall","docId":"N+1","unlisted":false},{"type":"link","label":"Authentication","href":"/docs/field-level-access-control-graphql-authentication","docId":"auth","unlisted":false},{"type":"link","label":"GraphQL on gRPC","href":"/docs/graphql-grpc-tailcall","docId":"grpc","unlisted":false},{"type":"link","label":"Custom Resolvers","href":"/docs/graphql-javascript-customization","docId":"scripting","unlisted":false},{"type":"link","label":"HTTP/2","href":"/docs/graphql-http2-guide-tailcall","docId":"http2","unlisted":false},{"type":"link","label":"Telemetry","href":"/docs/graphql-telemetry-guide","docId":"telemetry","unlisted":false},{"type":"link","label":"HTTP Cache","href":"/docs/graphql-http-cache-guide-tailcall","docId":"http-cache","unlisted":false},{"type":"link","label":"Log Levels","href":"/docs/graphql-logging-levels-tailcall","docId":"logging","unlisted":false},{"type":"link","label":"REST on GraphQL","href":"/docs/graphql-rest-integration","docId":"rest","unlisted":false},{"type":"link","label":"GraphQL Scalars","href":"/docs/graphql-scalars-guide","docId":"scalar","unlisted":false},{"type":"link","label":"Environment Variables","href":"/docs/graphql-environment-variables","docId":"environment-variables","unlisted":false},{"type":"link","label":"Configuration Formats","href":"/docs/tailcall-graphql-configuration-format-conversion","docId":"configuration","unlisted":false},{"type":"link","label":"Auto Generation","href":"/docs/graphql-configuration-generation-with-tailcall","docId":"config-generation","unlisted":false},{"type":"link","label":"Apollo Federation Subgraph","href":"/docs/integrate-apollo-federation-graphql-tailcall-subgraph","docId":"apollo-federation-subgraph","unlisted":false}],"collapsible":true},{"type":"category","label":"Integrations","collapsed":false,"items":[{"type":"link","label":"Apollo Studio","href":"/docs/integrate-apollo-studio-graphql-tailcall","docId":"apollo-studio","unlisted":false},{"type":"link","label":"Data Dog","href":"/docs/graphql-data-dog-telemetry-tailcall","docId":"data-dog","unlisted":false},{"type":"link","label":"New Relic","href":"/docs/graphql-newrelic-guide-telemetry","docId":"new-relic","unlisted":false},{"type":"link","label":"Honeycomb","href":"/docs/graphql-honeycomb-telemetry-tailcall","docId":"honey-comb","unlisted":false},{"type":"link","label":"LLM Integration","href":"/docs/llm-integration","docId":"llm","unlisted":false}],"collapsible":true},{"type":"category","label":"Production","collapsed":false,"items":[{"type":"link","label":"Deployments","href":"/docs/deploy-graphql-github-actions","docId":"gh-action","unlisted":false},{"type":"link","label":"Deploy on Fly","href":"/docs/deploy-tailcall-graphql-fly-actions","docId":"tailcall-on-fly","unlisted":false},{"type":"link","label":"Deploy on AWS","href":"/docs/tailcall-on-aws","docId":"tailcall-on-aws","unlisted":false},{"type":"link","label":"Performance Tuning","href":"/docs/graphql-client-performance-tuning","docId":"client-tuning","unlisted":false}],"collapsible":true},{"type":"category","label":"Contributors","collapsed":false,"items":[{"type":"link","label":"Guidelines","href":"/docs/contribution-guidelines","docId":"contributors/guidelines","unlisted":false},{"type":"link","label":"Bounty","href":"/docs/contributors/bounty","docId":"contributors/bounty","unlisted":false},{"type":"link","label":"Unit Testing","href":"/docs/contributors/testing","docId":"contributors/testing","unlisted":false},{"type":"link","label":"Integration Testing","href":"/docs/contributors/integration-testing","docId":"contributors/integration-testing","unlisted":false},{"type":"link","label":"Mutability","href":"/docs/contributors/mutability","docId":"contributors/mutability","unlisted":false},{"type":"link","label":"Telemetry","href":"/docs/contributors/telemetry","docId":"contributors/telemetry","unlisted":false},{"type":"link","label":"Micro Benchmarks","href":"/docs/contributors/micro-benchmark","docId":"contributors/micro-benchmark","unlisted":false},{"type":"link","label":"Macro Benchmarks","href":"/docs/contributors/wrk-benchmark","docId":"contributors/wrk-benchmark","unlisted":false}],"collapsible":true}]},"docs":{"apollo-federation-subgraph":{"id":"apollo-federation-subgraph","title":"Use Tailcall service as a Federation Subgraph","description":"Learn how to configure Tailcall to function as an Apollo Federation Subgraph, enabling seamless integration into a federated GraphQL environment.","sidebar":"docs"},"apollo-studio":{"id":"apollo-studio","title":"Integrating Tailcall with Apollo Studio","description":"Enhance your GraphQL server\'s efficiency by integrating Tailcall with Apollo Studio using our concise guide. Learn how to configure Tailcall to send vital usage metrics to Apollo Studio for advanced performance monitoring and optimization. Whether you\'re establishing a Monolith graph or improving an existing one, our instructions facilitate seamless integration. Set up for better insights and leverage Apollo Studio\'s features for a more responsive GraphQL server. Start optimizing today with our straightforward steps and explore Apollo Studio\'s free trial for new users.","sidebar":"docs"},"auth":{"id":"auth","title":"Field Level GraphQL Authentication","description":"Discover how to provide granular access to types and fields in your GraphQL schema using authentication providers. Our guide helps you enhance security and control by configuring precise access levels within your GraphQL server. Start implementing advanced access control measures today.","sidebar":"docs"},"cli":{"id":"cli","title":"Command Line Reference","description":"Discover the Tailcall CLI, a crucial tool for developers to manage and optimize GraphQL configurations from the command line. Learn commands like \'check\', \'start\', \'init\', and \'gen\' to validate specs, launch servers, bootstrap projects, and generate configurations. Detect N+1 issues, display schemas, format inputs, and more. Simplify GraphQL composition and enhance your development workflow with Tailcall CLI.","sidebar":"docs"},"client-tuning":{"id":"client-tuning","title":"Optimizing Performance of your GraphQL Server","description":"Learn how to tune your client for optimal performance. Our guide provides essential tips and techniques to enhance responsiveness and efficiency in your applications. Start optimizing your client today for a faster, smoother user experience.","sidebar":"docs"},"config-generation":{"id":"config-generation","title":"Automatic GraphQL Configuration Generation with Tailcall","description":"Migrate REST or gRPC APIs to GraphQL automatically","sidebar":"docs"},"configuration":{"id":"configuration","title":"GraphQL Configuration Formats","description":"Explore the format conversion capabilities of the Tailcall CLI, supporting GraphQL, YAML, and JSON for configuration files. This documentation shows developers how to effortlessly convert and manage configurations, leveraging GraphQL for clear type definitions, and YAML and JSON for their ubiquity in tools and API integration. Enhance your development and deployment workflows today.","sidebar":"docs"},"context":{"id":"context","title":"GraphQL Resolver Context","description":"Explore Tailcall\'s dynamic Context mechanism for schema field resolution, enabling access to arguments, values, and environment variables for efficient GraphQL queries. Enhance your query handling with Tailcall\'s advanced Context features for optimized schema field resolution.","sidebar":"docs"},"contributors/bounty":{"id":"contributors/bounty","title":"Bounty","description":"This guide outlines the Tailcall Bounty Program, emphasizing quick, high-quality contributions and collaborative engagement through challenges and rewards. It provides essential participation rules and encourages active community involvement for innovation and excellence.","sidebar":"docs"},"contributors/guidelines":{"id":"contributors/guidelines","title":"Guidelines","description":"Explore how to contribute to the Tailcall project with this SEO-optimized guide. Learn the best practices for collaborating effectively, from forking and setting up your environment with tools like Rust and Prettier, to making incremental changes and engaging in community discussions. This document outlines key steps like creating new branches, submitting pull requests, and ensuring high code quality. Whether you\'re discussing on Discord or pushing changes, these guidelines ensure a smooth process. Perfect for developers looking to contribute to a thriving, respectful, and inclusive community. Join and enhance the Tailcall project today!","sidebar":"docs"},"contributors/integration-testing":{"id":"contributors/integration-testing","title":"Integration Testing","description":"Discover Tailcall\'s innovative markdown-based snapshot testing framework, designed to enhance testing across various programming languages seamlessly. This framework focuses on simplicity and maintainability, utilizing Markdown to make test cases easy to write and understand. Tailored for users of Tailcall, the framework supports extensive testing of GraphQL backends without language constraints. Features include detailed instructions on running and filtering tests, a structured test syntax guide, and comprehensive sections on test processes and snapshot maintenance. Ideal for developers seeking a straightforward, language-agnostic testing solution. Learn more about implementing and maintaining effective tests with Tailcall\'s unique approach.","sidebar":"docs"},"contributors/micro-benchmark":{"id":"contributors/micro-benchmark","title":"Micro Benchmarks","description":"Explore Tailcall\'s comprehensive guide to benchmarking for continuous integration (CI) systems. Learn how to seamlessly integrate and run performance tests on every commit to the main branch using Criterion. The guide covers installation of essential tools like cargo-criterion and rust-script, provides step-by-step instructions for executing benchmarks, and details procedures for comparing benchmark results across different code branches. Ensure code efficiency and detect performance degradations early with Tailcall\'s benchmarking strategies, essential for developers seeking to maintain and improve software performance consistently. Visit the complete guide to start optimizing your CI pipeline today.","sidebar":"docs"},"contributors/mutability":{"id":"contributors/mutability","title":"Mutability","description":"Explore best practices for handling mutability in programming with our detailed guide. Learn when to use references versus ownership in functions with clear examples. This guideline helps developers optimize their code for better performance and clarity, especially in performance-sensitive environments. Ideal for contributors and programmers looking to refine their coding techniques and understanding of mutability.","sidebar":"docs"},"contributors/telemetry":{"id":"contributors/telemetry","title":"Telemetry","description":"Discover how to elevate application observability with Tailcall\'s comprehensive guide on implementing telemetry using the OpenTelemetry specification. This guide provides a detailed overview of using Rust crates such as rust-opentelemetry, tracing, and tracing-opentelemetry for effective data collection and export. It includes specific examples and best practices for tracing significant operations, naming spans accurately, and adhering to semantic conventions. Perfect for developers seeking to enhance monitoring and debugging capabilities in their applications, this resource is your go-to for integrating advanced observability features efficiently. Learn more about how to optimize your development process by visiting Tailcall\'s contributor guidelines.","sidebar":"docs"},"contributors/testing":{"id":"contributors/testing","title":"Unit Testing","description":"Discover the Tailcall\'s Testing Guidelines designed for contributors. This guide covers our testing approach, how to run and write tests, and tips for troubleshooting. It\'s a straightforward resource for developers at any level aiming to contribute effectively and maintain high-quality code in Tailcall","sidebar":"docs"},"contributors/wrk-benchmark":{"id":"contributors/wrk-benchmark","title":"Macro Benchmarks","description":"Learn how to benchmark a Tailcall server using `wrk` with this comprehensive guide. Discover the steps for building your project in release mode, starting the server with controlled log output, and using `wrk` with a custom Lua script for precise benchmarking. This tutorial also covers how to verify server responsiveness with `curl` and how to interpret benchmark results to assess server performance under load. Perfect for developers looking to optimize their Rust applications.","sidebar":"docs"},"conventions":{"id":"conventions","title":"GraphQL Best Practices","description":"Enhance your understanding of naming and casing conventions for GraphQL schema to ensure clarity and consistency in your schema design using Tailcall. Learn best practices for naming to maintain a well-structured and readable GraphQL schema.","sidebar":"docs"},"data-dog":{"id":"data-dog","title":"Data Dog Telemetry Integration","description":"Discover how to enhance application performance with our guide on enabling and analyzing telemetry data in Tailcall. Learn to configure observability support using OpenTelemetry for insights into logs, metrics, and traces, with practical integration examples for platforms like Honeycomb.io, New Relic, and Datadog.","sidebar":"docs"},"directives":{"id":"directives","title":"GraphQL Configuration","description":"Enhance your GraphQL API with Tailcall DSL\'s custom directives. These directives offer powerful compile-time guarantees, ensuring robust and optimized API composition. Tailcall automates the generation of resolver logic for improved performance.","sidebar":"docs"},"environment-variables":{"id":"environment-variables","title":"Reading Environment Variables","description":"Learn how to effectively manage environment variables in your Tailcall GraphQL schema, enhancing security and flexibility in your application configuration. This guide explores the need for environment variables, their implementation in Tailcall schemas, and best practices for security and management.","sidebar":"docs"},"execution-strategy":{"id":"execution-strategy","title":"Sequencing & Parallelism","description":"Tailcall revolutionizes data access layer development by automating API call orchestration, ensuring optimal execution strategies through advanced sequencing and parallelism techniques.","sidebar":"docs"},"getting-started":{"id":"getting-started","title":"Getting Started with GraphQL","description":"Discover how to efficiently get started with GraphQL using Tailcall, enhancing your data access capabilities through optimized execution strategies.","sidebar":"docs"},"gh-action":{"id":"gh-action","title":"Github Action for Deploying GraphQL","description":"Deploy GraphQL servers effortlessly with GitHub Actions.","sidebar":"docs"},"grpc":{"id":"grpc","title":"Step-by-Step Tutorial: Building GraphQL over gRPC","description":"Learn how gRPC and GraphQL boost microservices. Discover their benefits and how they work together for better APIs.","sidebar":"docs"},"honey-comb":{"id":"honey-comb","title":"Honeycomb Telemetry Integration","description":"Enhance your application\'s performance with our guide on enabling and analyzing telemetry data in Tailcall. Learn how to configure observability support using OpenTelemetry for comprehensive insights into logs, metrics, and traces. This guide includes practical integration examples for platforms such as Honeycomb.io, New Relic, and Datadog.","sidebar":"docs"},"http-cache":{"id":"http-cache","title":"Using HTTP Cache","description":"A comprehensive guide to leverage HTTP cache for REST APIs using Tailcall.","sidebar":"docs"},"http2":{"id":"http2","title":"GraphQL over HTTP/2","description":"Boost web performance and secure your communications by utilizing HTTP/2 with Tailcall GraphQL.","sidebar":"docs"},"llm":{"id":"llm","title":"LLM Integration","description":"List of all the supported LLM models that Tailcall uses","sidebar":"docs"},"logging":{"id":"logging","title":"Logging Levels Configuration","description":"Learn how to configure log levels in Tailcall to obtain insights into code execution and address software development challenges. Discover the available log levels, set verbosity via environment variables, and understand the hierarchy of log levels for effective logging.","sidebar":"docs"},"N+1":{"id":"N+1","title":"Solving GraphQL N+1 Problem with Tailcall","description":"Master the GraphQL N+1 problem and learn detection and solutions to enhance API efficiency.","sidebar":"docs"},"new-relic":{"id":"new-relic","title":"New Relic Telemetry Integration","description":"Discover how to enhance application performance with our guide on enabling and analyzing telemetry data in Tailcall. Learn to configure observability support using OpenTelemetry for insights into logs, metrics, and traces, with practical integration examples for platforms like Honeycomb.io, New Relic, and Datadog.","sidebar":"docs"},"playground":{"id":"playground","title":"GraphQL Playground","description":"Explore and test server configurations with the @server directive\'s showcase feature in a controlled environment. Ideal for quick experimentation and learning with dynamic GraphQL schema configurations. Not recommended for production due to performance and security considerations.","sidebar":"docs"},"rest":{"id":"rest","title":"Exposing GraphQL as REST APIs","description":"Exposing REST endpoints on top of GraphQL via the @rest directive.","sidebar":"docs"},"scalar":{"id":"scalar","title":"Simplifying GraphQL Scalars","description":"Explore GraphQL\'s core and Tailcall\'s custom scalars, including `Int`, `Float`, `String`, `Boolean`, `ID`, `Email`, and more, in our guide that simplifies data handling with clear definitions and examples. Enhance your applications with our comprehensive scalar support, designed for precise data validation and efficiency.","sidebar":"docs"},"scripting":{"id":"scripting","title":"Customizing using Javascript","description":"Discover how to effortlessly manipulate HTTP requests and responses using Tailcall\'s lightweight JS runtime. Tailcall provides a streamlined JavaScript environment specifically designed for simple yet powerful request/response modifications without the complexity of a full Node.js setup. Ideal for developers looking to implement middleware solutions, Tailcall\'s runtime does not require file system or network access, ensuring a secure and focused development process.","sidebar":"docs"},"tailcall-on-aws":{"id":"tailcall-on-aws","title":"Deploy Tailcall on AWS Lambda","description":"Deploy `tailcall` on AWS Lambda using the github action `tailcallhq/gh-action`","sidebar":"docs"},"tailcall-on-fly":{"id":"tailcall-on-fly","title":"Deploy Tailcall GraphQL on Fly.io","description":"Learn how to deploy Tailcall GraphQL servers on Fly.io using GitHub Actions quickly and securely.","sidebar":"docs"},"telemetry":{"id":"telemetry","title":"GraphQL Telemetry","description":"Learn how to configure observability support using OpenTelemetry for insights into logs, metrics, and traces. Discover practical integration examples for platforms like Honeycomb.io, New Relic, and Datadog.","sidebar":"docs"},"watch-mode":{"id":"watch-mode","title":"GraphQL Server Watch Mode","description":"Learn how to enhance your development workflow by running servers in watch mode with the versatile file-watcher tool, entr. This guide provides installation instructions for different operating systems, usage tips, and best practices to optimize your development process.","sidebar":"docs"}}}}')}}]);