"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6497],{92473:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var i=s(74848),t=s(28453);const a={title:"GraphQL Best Practices",description:"Enhance your understanding of naming and casing conventions for GraphQL schema to ensure clarity and consistency in your schema design using Tailcall. Learn best practices for naming to maintain a well-structured and readable GraphQL schema.",slug:"graphql-best-practices-tailcall",sidebar_label:"Best Practices"},r=void 0,c={id:"conventions",title:"GraphQL Best Practices",description:"Enhance your understanding of naming and casing conventions for GraphQL schema to ensure clarity and consistency in your schema design using Tailcall. Learn best practices for naming to maintain a well-structured and readable GraphQL schema.",source:"@site/docs/conventions.md",sourceDirName:".",slug:"/graphql-best-practices-tailcall",permalink:"/docs/graphql-best-practices-tailcall",draft:!1,unlisted:!1,editUrl:"https://github.com/tailcallhq/tailcallhq.github.io/tree/develop/docs/conventions.md",tags:[],version:"current",lastUpdatedAt:1717408113e3,frontMatter:{title:"GraphQL Best Practices",description:"Enhance your understanding of naming and casing conventions for GraphQL schema to ensure clarity and consistency in your schema design using Tailcall. Learn best practices for naming to maintain a well-structured and readable GraphQL schema.",slug:"graphql-best-practices-tailcall",sidebar_label:"Best Practices"},sidebar:"docs",previous:{title:"GraphQL Playground",permalink:"/docs/graphql-playground-guide"},next:{title:"Sequence vs Parallel",permalink:"/docs/graphql-data-access-parallel-vs-sequence"}},l={},d=[{value:"General Naming Principles",id:"general-naming-principles",level:2},{value:"Detailed Naming Cases",id:"detailed-naming-cases",level:2},{value:"Fields, Arguments, and Directives",id:"fields-arguments-and-directives",level:3},{value:"Types",id:"types",level:3},{value:"Field Naming Best Practices",id:"field-naming-best-practices",level:2},{value:"Queries",id:"queries",level:3},{value:"Mutations",id:"mutations",level:3},{value:"Type Naming Conventions",id:"type-naming-conventions",level:2},{value:"Input Types",id:"input-types",level:3},{value:"Output Types",id:"output-types",level:3},{value:"Advanced Naming Strategies",id:"advanced-naming-strategies",level:2},{value:"Resolving Namespace Conflicts",id:"resolving-namespace-conflicts",level:3},{value:"Conclusion",id:"conclusion",level:2}];function o(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"general-naming-principles",children:"General Naming Principles"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistency is Key:"})," Ensure that naming conventions are uniform across your entire schema to maintain clarity and consistency."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Descriptive Over Generic:"})," Opt for descriptive, specific names rather than broad, generic ones to avoid ambiguity."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Avoid Abbreviations:"})," Avoid the use of acronyms, initialism, and abbreviations to keep your schema intuitive and understandable."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"detailed-naming-cases",children:"Detailed Naming Cases"}),"\n",(0,i.jsx)(n.h3,{id:"fields-arguments-and-directives",children:"Fields, Arguments, and Directives"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Adopt ",(0,i.jsx)(n.code,{children:"camelCase"}),":"]})," Utilize ",(0,i.jsx)(n.code,{children:"camelCase"})," for field names, argument names, and directive names to achieve a clear, consistent structure."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  postTitle(userId: Int): String\n}\n\ndirective @includeIf on FIELD\n"})}),"\n",(0,i.jsx)(n.h3,{id:"types",children:"Types"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Prefer ",(0,i.jsx)(n.code,{children:"PascalCase"}),":"]})," Use ",(0,i.jsx)(n.code,{children:"PascalCase"})," for defining types, enabling easy identification and differentiation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Post { ... }\nenum StatusEnum { ... }\ninterface UserInterface { ... }\nunion SearchResult = ...\nscalar Date\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Enum Values in ",(0,i.jsx)(n.code,{children:"SCREAMING_SNAKE_CASE"}),":"]})," Distinguish enum values by using ",(0,i.jsx)(n.code,{children:"SCREAMING_SNAKE_CASE"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"enum StatusEnum {\n  PUBLISHED\n  DRAFT\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"field-naming-best-practices",children:"Field Naming Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"queries",children:"Queries"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Avoid ",(0,i.jsx)(n.code,{children:"get"})," or ",(0,i.jsx)(n.code,{children:"list"})," Prefixes:"]})," Refrain from using prefixes like ",(0,i.jsx)(n.code,{children:"get"})," or ",(0,i.jsx)(n.code,{children:"list"})," in your query names to ensure predictability and consistency."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  # \ud83d\udc4e Avoid\n  getPosts: [Post]\n\n  # \ud83d\udc4d Prefer\n  posts: [Post]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Maintain consistency between root and nested fields:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# \ud83d\udc4e Avoid\nquery PostQuery {\n  getPosts {\n    id\n    getUser {\n      name\n    }\n  }\n}\n\n# \ud83d\udc4d Prefer\nquery PostQuery {\n  posts {\n    id\n    user {\n      name\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"mutations",children:"Mutations"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Verb Prefixes for Mutations:"})," Begin mutation field names with a verb to indicate the action being performed, improving schema readability."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n  # \ud83d\udc4e Avoid\n  postAdd(input: AddPostInput): AddPostPayload!\n\n  # \ud83d\udc4d Prefer\n  addPost(input: AddPostInput): AddPostPayload!\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"type-naming-conventions",children:"Type Naming Conventions"}),"\n",(0,i.jsx)(n.h3,{id:"input-types",children:"Input Types"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"Input"})," Suffix:"]})," Denote input types by appending ",(0,i.jsx)(n.code,{children:"Input"})," to their names, specifying their use case."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"input AddPostInput {\n  title: String!\n  body: String!\n  userId: Int!\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"output-types",children:"Output Types"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"Response"})," or ",(0,i.jsx)(n.code,{children:"Payload"})," Suffix:"]})," Use a consistent suffix like ",(0,i.jsx)(n.code,{children:"Response"})," or ",(0,i.jsx)(n.code,{children:"Payload"})," for the output types resulting from mutations."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n  addPost(input: AddPostInput!): AddPostResponse!\n}\n\ntype AddPostResponse {\n  success: Boolean!\n  post: Post\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-naming-strategies",children:"Advanced Naming Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"resolving-namespace-conflicts",children:"Resolving Namespace Conflicts"}),"\n",(0,i.jsx)(n.p,{children:"For addressing naming conflicts across different domains within your schema:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"PascalCase"})," Prefix:"]})," Distinguish similar types from distinct domains for clear separation without resorting to underscores. This method ensures a cleaner, more professional look while maintaining the integrity and readability of your schema."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type BlogPost { ... }\ntype ForumPost { ... }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Implementing a consistent, descriptive, and intuitive naming convention is crucial for developing an understandable and maintainable GraphQL schema. By following the best practices outlined you can improve the clarity and effectiveness of your schema."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var i=s(96540);const t={},a=i.createContext(t);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);