"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2770],{7486:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=t(74848),s=t(28453);const r={title:"GraphQL vs gRPC: Which is Better? Uncover the Best Choice!",sidebar_label:"gRPC vs graphQL",description:"Discover the differences between GraphQL and gRPC. Learn which is better for your needs in this comprehensive guide. Find out now!",image:"/images/graphql/graphql-vs-grpc.png",authors:[{name:"Hunain Ahmed",title:"A freelance software developer, always working on something new and fascinating.",url:"https://github.com/hunxjunedo",image_url:"https://avatars.githubusercontent.com/u/89797440?v=4"}],hide_table_of_contents:!0,slug:"graphql-vs-grpc"},a=void 0,o={permalink:"/blog/graphql-vs-grpc",source:"@site/blog/grpc-vs-graphql-2024-07-26.mdx",title:"GraphQL vs gRPC: Which is Better? Uncover the Best Choice!",description:"Discover the differences between GraphQL and gRPC. Learn which is better for your needs in this comprehensive guide. Find out now!",date:"2024-07-26T00:00:00.000Z",tags:[],readingTime:8.02,hasTruncateMarker:!0,authors:[{name:"Hunain Ahmed",title:"A freelance software developer, always working on something new and fascinating.",url:"https://github.com/hunxjunedo",image_url:"https://avatars.githubusercontent.com/u/89797440?v=4",imageURL:"https://avatars.githubusercontent.com/u/89797440?v=4"}],frontMatter:{title:"GraphQL vs gRPC: Which is Better? Uncover the Best Choice!",sidebar_label:"gRPC vs graphQL",description:"Discover the differences between GraphQL and gRPC. Learn which is better for your needs in this comprehensive guide. Find out now!",image:"/images/graphql/graphql-vs-grpc.png",authors:[{name:"Hunain Ahmed",title:"A freelance software developer, always working on something new and fascinating.",url:"https://github.com/hunxjunedo",image_url:"https://avatars.githubusercontent.com/u/89797440?v=4",imageURL:"https://avatars.githubusercontent.com/u/89797440?v=4"}],hide_table_of_contents:!0,slug:"graphql-vs-grpc"},unlisted:!1,prevItem:{title:"GraphQL vs OpenAPI: Part 1 of the API Comparison Series",permalink:"/blog/graphql-vs-openapi-part-1"},nextItem:{title:"Exploring GraphiQL: The In-Browser IDE for GraphQL",permalink:"/blog/exploring-graphiql"}},h={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"The Problem",id:"the-problem",level:2},{value:"Knowing gRPC",id:"knowing-grpc",level:2},{value:"Unleashing GraphQL Magic!",id:"unleashing-graphql-magic",level:2},{value:"Feature Comparison",id:"feature-comparison",level:2},{value:"Scenarios for Using gRPC",id:"scenarios-for-using-grpc",level:2},{value:"Scenario 1: A social media app backend",id:"scenario-1-a-social-media-app-backend",level:3},{value:"Scenario 2: A movie streaming backend",id:"scenario-2-a-movie-streaming-backend",level:3},{value:"Scenarios for Using GraphQL",id:"scenarios-for-using-graphql",level:2},{value:"Scenario 1: Fetching Multiple Items",id:"scenario-1-fetching-multiple-items",level:3},{value:"Scenario 2: Ecommerce App",id:"scenario-2-ecommerce-app",level:3},{value:"Integrating gRPC and GraphQL",id:"integrating-grpc-and-graphql",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"banner",src:t(27352).A+"",width:"966",height:"332"})}),"\n",(0,i.jsx)(n.p,{children:"While REST has been the go-to for API development, gRPC and GraphQL are stepping in as game-changing contenders."}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"When it comes to choosing the tech stack for your application, it's never a straightforward task, especially when choosing between gRPC and graphQL - both backed by tech giants. Follow us as we discuss real world scenarios and perform a detailed feature-comparison on both, concluding exactly where each should be used."}),"\n",(0,i.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s say you are building a social app like Reddit, and you have screens like home and popular. You implement a simple REST API on the backend and everything looks fine:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"it wasn\u2019t so challenging to setup"}),"\n",(0,i.jsx)(n.li,{children:"has tons of resources if anything goes wrong"}),"\n",(0,i.jsx)(n.li,{children:"seems like a perfect solution."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Until the user base grows and there\u2019s thousands of users - and disaster strikes: the loading times increase and the costs skyrocket, you begin to lose engagement of the users."}),"\n",(0,i.jsx)(n.p,{children:"Deep down, the root cause of this problem is the slow nature of REST and over-fetching. What happens is that when a user opens the app, goes to the home screen, and the app fetches tons of unnecessary data from the backend: all pictures of a post, all comments and even related posts! Which is even worsened by the fact that the client has to call multiple endpoints to finally show the feed to the user. You are stuck in performance jargon, let\u2019s rewind it. You use graphQL instead of REST, which has many advantages over the REST:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"thanks to its predefined schemas you don\u2019t have to spend hours writing simple validation tests to check that a parameter is a number and not a string."}),"\n",(0,i.jsx)(n.li,{children:"graphQL only serves what the client asks for, which means there\u2019s no chance of over-fetching"}),"\n",(0,i.jsx)(n.li,{children:"not to mention that one endpoint of graphQL is more useful and comprehensive than 5 REST API routes."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"knowing-grpc",children:"Knowing gRPC"}),"\n",(0,i.jsxs)(n.p,{children:["So what is behind the magic of gRPC ? Since Google open-sourced it in 2015, gRPC has been revolutionizing service-to-service communication with its robust, schema-driven framework. By harnessing the power of HTTP/2 and Protocol Buffers (Protobuf), gRPC unleashes high-performance, real-time data streaming and rock-solid typing - a winning combo that's made it a go-to tool for developers building scalable, efficient systems. No wonder tech titans like ",(0,i.jsx)(n.a,{href:"https://theirstack.com/en/technology/grpc",children:"Tesla, Netflix, Coinbase and Dropbox"})," are all on board!"]}),"\n",(0,i.jsxs)(n.p,{children:["Read more about ",(0,i.jsx)(n.a,{href:"/blog/what-is-grpc/",children:"What is gRPC"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"companies using grpc",src:t(39481).A+"",width:"1127",height:"402"})}),"\n",(0,i.jsx)(n.h2,{id:"unleashing-graphql-magic",children:"Unleashing GraphQL Magic!"}),"\n",(0,i.jsxs)(n.p,{children:["GraphQL, born at Facebook in 2012 and unleashed to the world in 2015, revolutionizes API queries. It\u2019s a powerful and flexible alternative to REST APIs, featuring declarative data fetching that ensures you get just the data you need\u2014no more, no less. With a single endpoint, GraphQL simplifies API structures, eliminating the hassle of managing multiple endpoints. This efficiency and flexibility have made it the darling of tech giants like ",(0,i.jsx)(n.a,{href:"https://landscape.graphql.org/borderless-mode?grouping=category",children:"Github, Meta, Shopify and Microsoft "}),". With GraphQL, you can build more efficient and intuitive APIs that make data fetching a breeze!"]}),"\n",(0,i.jsxs)(n.p,{children:["Read more about ",(0,i.jsx)(n.a,{href:"/graphql/what-is-graphql",children:"What is GraphQL and How it works?"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"companies using graphql",src:t(30618).A+"",width:"974",height:"249"})}),"\n",(0,i.jsx)(n.h2,{id:"feature-comparison",children:"Feature Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"gRPC"}),(0,i.jsx)(n.th,{children:"GraphQL"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Message Format"})}),(0,i.jsx)(n.td,{children:"Binary"}),(0,i.jsx)(n.td,{children:"JSON"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Data Fetching"})}),(0,i.jsx)(n.td,{children:"Fixed endpoints and methods"}),(0,i.jsx)(n.td,{children:"Flexible queries, specified by clients"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Real-Time"})}),(0,i.jsx)(n.td,{children:"Supports streaming via server-side push"}),(0,i.jsx)(n.td,{children:"Supports real-time updates via subscriptions"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Type Safety"})}),(0,i.jsx)(n.td,{children:"Strongly typed with Protocol Buffers"}),(0,i.jsx)(n.td,{children:"Strongly typed with schema definition"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Introspection"})}),(0,i.jsx)(n.td,{children:"No built-in introspection"}),(0,i.jsx)(n.td,{children:"Built-in schema introspection"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Code Generation"})}),(0,i.jsx)(n.td,{children:"Automatic code generation from .proto files"}),(0,i.jsx)(n.td,{children:"Code generation tools available, but not automatic"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Tooling and Browser Support"})}),(0,i.jsx)(n.td,{children:"Limited browser support, requires proxies for web use"}),(0,i.jsx)(n.td,{children:"Strong tooling support, works natively in browsers"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Community"})}),(0,i.jsx)(n.td,{children:"currently nascent"}),(0,i.jsx)(n.td,{children:"Growing rapidly, strong in web and mobile development"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Adoption"})}),(0,i.jsx)(n.td,{children:"widely in microservices"}),(0,i.jsxs)(n.td,{children:["mostly in mobile app development and ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Progressive_web_app",children:"PWA"}),"s"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Performance"})}),(0,i.jsx)(n.td,{children:"High performance with low latency"}),(0,i.jsx)(n.td,{children:"Generally efficient, schemas defined correctly"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Debugging and Troubleshooting"})}),(0,i.jsx)(n.td,{children:"non-human-readable format, require tools for debugging."}),(0,i.jsx)(n.td,{children:"JSON response is easier to read and debug"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"scenarios-for-using-grpc",children:"Scenarios for Using gRPC"}),"\n",(0,i.jsx)(n.p,{children:"The ideal scenario for gRPC? When microservices need to communicate at lightning speed and with top-notch efficiency! Think of gRPC as the ultimate express lane for data\u2014perfect when you need swift, reliable interactions and don\u2019t need to be super flexible. It\u2019s like having a fast track for your information, keeping everything running smoothly and quickly!"}),"\n",(0,i.jsx)(n.h3,{id:"scenario-1-a-social-media-app-backend",children:"Scenario 1: A social media app backend"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"sm app example",src:t(51764).A+"",width:"1176",height:"561"})}),"\n",(0,i.jsx)(n.p,{children:"Imagine a social media app where everything works like clockwork. Here\u2019s how gRPC fits in:\nThe Cast:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Media-Scanner: Analyzes media files with precision."}),"\n",(0,i.jsx)(n.li,{children:"Media-Tagger: Tags content accurately."}),"\n",(0,i.jsx)(n.li,{children:"Jobs-Manager: Handles tasks efficiently."}),"\n",(0,i.jsx)(n.li,{children:"Followers-Notifier: Sends timely updates to users."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In this setup, gRPC\u2019s Protocol Buffers ensure fast, efficient communication, cutting down on overhead and latency. Each service gets exactly what it needs, there's no risk of overfetching. It\u2019s a perfect match for microservices, where speed and efficiency are key."}),"\n",(0,i.jsx)(n.h3,{id:"scenario-2-a-movie-streaming-backend",children:"Scenario 2: A movie streaming backend"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"movie app example",src:t(38396).A+"",width:"1317",height:"592"})}),"\n",(0,i.jsx)(n.p,{children:"Imagine the backend of a movie-streaming app, where Content-Age-Rater, Relations-Builder, Subtitles-Generator, and Subtitles-Translator each have their own star roles. They rate movies, connect related content, create subtitles, and translate them with precision. With gRPC, these services chat efficiently, making sure data zips around quickly and smoothly. No extra baggage\u2014just a slick, high-performance team working seamlessly together. It\u2019s like having a top-notch crew behind the scenes, making sure everything runs smooth! \ud83c\udfac\ud83c\udf7f"}),"\n",(0,i.jsx)(n.h2,{id:"scenarios-for-using-graphql",children:"Scenarios for Using GraphQL"}),"\n",(0,i.jsx)(n.p,{children:"GraphQL shines when you need to tailor data fetching to match your frontend's needs precisely. It allows for fetching exactly the data you need, nothing more, nothing less, which can be a game-changer for optimizing performance and reducing over-fetching. This flexibility can really streamline interactions between the frontend and backend, especially in complex applications, as we discuss below:"}),"\n",(0,i.jsx)(n.h3,{id:"scenario-1-fetching-multiple-items",children:"Scenario 1: Fetching Multiple Items"}),"\n",(0,i.jsx)(n.p,{children:"GitHub uses GraphQL to make fetching PR details a breeze. With gRPC, you'd have to set up different RPC methods for each data type\u2014comments, commits, changed files\u2014potentially resulting in several requests. Often, you just need the first and last comments right off the bat. GraphQL swoops in, pulling exactly those details with one neat query, cutting down on network strain and speeding things up."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'query {\n  repository(owner: "username", name: "repository-name") {\n    pullRequest(number: 123) {\n      title\n      createdAt\n      updatedAt\n      author {\n        login\n        avatarUrl\n      }\n      comments(first: 2, orderBy: {field: CREATED_AT, direction: ASC}) {\n        nodes {\n          author {\n            login\n          }\n          body\n          createdAt\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Instagram uses a smart approach to fetch just a handful of comments on a reel\u2014those that show up right under the title without diving into the full comments section. It\u2019d be a hassle to pull 10 or 20 comments when only 5 are needed. This is where GraphQL shines, perfectly tuned for getting just the right data without any extra fluff."}),"\n",(0,i.jsx)(n.h3,{id:"scenario-2-ecommerce-app",children:"Scenario 2: Ecommerce App"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"graphql fetch",src:t(9302).A+"",width:"631",height:"498"})}),"\n",(0,i.jsx)(n.p,{children:"Think about an ecommerce app with loads of products. On the explore page, users just want a quick snapshot\u2014picture, name, and a brief description. But when they dive into a product page, they\u2019re looking for more details like weight and extra images. With gRPC, you\u2019d need separate calls for each view, which can be a bit clunky and might pull in extra data. GraphQL, on the other hand, lets you customize your queries to get just what you need for each page, cutting down on excess data and making everything run smoother:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"query {\n  products {\n    id\n    name\n    shortDescription\n    imageUrl\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"For the product details page:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'query {\n  product(id: "product-id") {\n    id\n    name\n    description\n    weight\n    images {\n      url\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This approach makes data retrieval a breeze and keeps performance top-notch, highlighting why GraphQL shines in dynamic content and ecommerce apps over gRPC. It\u2019s all about getting exactly what you need, when you need it, and keeping things running smoothly!"}),"\n",(0,i.jsx)(n.h2,{id:"integrating-grpc-and-graphql",children:"Integrating gRPC and GraphQL"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"integrating both",src:t(22532).A+"",width:"1639",height:"883"})}),"\n",(0,i.jsx)(n.p,{children:"Picture a social media app where the backend whips up user feeds based on activity. The frontend needs different data for various screens\u2014blogs or videos\u2014so grabbing everything at once would be overkill. GraphQL steps in to save the day by letting the frontend fetch just what it needs, keeping things snappy and efficient."}),"\n",(0,i.jsx)(n.p,{children:"Meanwhile, backend services like feed-generator and logs-handler are busy creating and analyzing feeds. They require steady input and don\u2019t need much tweaking once live. For this, gRPC is perfect with its lightning-fast performance and low latency."}),"\n",(0,i.jsx)(n.p,{children:"By mixing GraphQL on the frontend with gRPC on the backend, you get a dynamic, high-performance setup. GraphQL fine-tunes data requests while gRPC keeps backend communication smooth."}),"\n",(0,i.jsxs)(n.p,{children:["Read this guide explaining the challenges and details associated with integrating gRPC and graphQL: ",(0,i.jsx)(n.a,{href:"/docs/graphql-grpc-tailcall",children:"Building GraphQL over gRPC"})," ."]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"In summary, both gRPC and graphQL have numerous advantages over each other, where gRPC has:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"more boosted performance"}),"\n",(0,i.jsx)(n.li,{children:"Low payload sizes"}),"\n",(0,i.jsx)(n.li,{children:"Simple and intuitive API design"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"On the other hand GraphQL takes the lead in:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"API flexibility"}),"\n",(0,i.jsx)(n.li,{children:"Friendly nature for web and mobile apps"}),"\n",(0,i.jsx)(n.li,{children:"Easier debugging"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"It doesn\u2019t matter which one is better, what truly matters is how good it is implemented, and how well it suits the use case. Remember - as Doug LInder likes to say -"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"\u201cA good programmer is someone who always looks both ways before crossing a one-way street\u201d"})})}),"\n",(0,i.jsx)(n.p,{children:"this simple concept can elevate you to the top tier of programmers."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},9302:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/fetch-graphql-7654cf09b4e791d41abd96c3c505161d.png"},22532:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/integration-c4e7414eb97c3a5cbe3932002583d021.png"},51764:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/services-4a44138776f5d5ceb658195b481afee7.png"},38396:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/services2-a55901f5189187f44c2b98357fdf3c12.png"},30618:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/stack-graphql-7437c6d607951f46a04946b5289c54f2.png"},39481:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/stack-grpc-45c00a79d8245dff061c371bd30a8ace.png"},27352:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/graphql-vs-grpc-8b9159597fdb4cd0ea4d89fc9fe869a4.png"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);