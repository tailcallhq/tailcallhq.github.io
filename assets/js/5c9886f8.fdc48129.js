"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2420],{56918:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var s=t(74848),r=t(28453),i=t(11470),a=t(19365);const l={title:"Automatic GraphQL Configuration Generation with Tailcall",description:"Migrate REST or gRPC APIs to GraphQL automatically",slug:"graphql-configuration-generation-with-tailcall",sidebar_label:"Auto Generation"},o=void 0,c={id:"config-generation",title:"Automatic GraphQL Configuration Generation with Tailcall",description:"Migrate REST or gRPC APIs to GraphQL automatically",source:"@site/docs/config-generation.md",sourceDirName:".",slug:"/graphql-configuration-generation-with-tailcall",permalink:"/docs/graphql-configuration-generation-with-tailcall",draft:!1,unlisted:!1,editUrl:"https://github.com/tailcallhq/tailcallhq.github.io/tree/develop/docs/config-generation.md",tags:[],version:"current",lastUpdatedAt:172723185e4,frontMatter:{title:"Automatic GraphQL Configuration Generation with Tailcall",description:"Migrate REST or gRPC APIs to GraphQL automatically",slug:"graphql-configuration-generation-with-tailcall",sidebar_label:"Auto Generation"},sidebar:"docs",previous:{title:"Configuration Formats",permalink:"/docs/tailcall-graphql-configuration-format-conversion"},next:{title:"Apollo Studio",permalink:"/docs/integrate-apollo-studio-graphql-tailcall"}},h={},d=[{value:"What is Configuration Generation?",id:"what-is-configuration-generation",level:2},{value:"Why is it Hard to Write GraphQL Schemas by Hand?",id:"why-is-it-hard-to-write-graphql-schemas-by-hand",level:3},{value:"Features",id:"features",level:2},{value:"Effortless REST Integration",id:"effortless-rest-integration",level:3},{value:"Effortless gRPC Integration",id:"effortless-grpc-integration",level:3},{value:"Hybrid Integration (REST + gRPC)",id:"hybrid-integration-rest--grpc",level:3},{value:"Example Configuration",id:"example-configuration",level:4},{value:"Inputs",id:"inputs",level:4},{value:"Understanding Presets",id:"understanding-presets",level:2},{value:"mergeType",id:"mergetype",level:3},{value:"consolidateURL",id:"consolidateurl",level:3},{value:"unwrapSingleFieldTypes",id:"unwrapsinglefieldtypes",level:3},{value:"treeShake",id:"treeshake",level:3},{value:"inferTypeNames",id:"infertypenames",level:3},{value:"LLM Powered Inference",id:"llm-powered-inference",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"FAQ&#39;s",id:"faqs",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Head:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t,{children:[(0,s.jsx)("meta",{property:"og:type",content:"article"}),(0,s.jsx)("title",{children:"Generate GraphQL Configuration"})]}),"\n","\n",(0,s.jsx)(n.h2,{id:"what-is-configuration-generation",children:"What is Configuration Generation?"}),"\n",(0,s.jsxs)(n.p,{children:["Configuration generation is the process of automatically generating graphQL configurations from the various sources such as ",(0,s.jsx)(n.strong,{children:"REST"}),", ",(0,s.jsx)(n.strong,{children:"gRPC"})," and already existing ",(0,s.jsx)(n.strong,{children:"GraphQL configuration"})," files."]}),"\n",(0,s.jsx)(n.h3,{id:"why-is-it-hard-to-write-graphql-schemas-by-hand",children:"Why is it Hard to Write GraphQL Schemas by Hand?"}),"\n",(0,s.jsx)(n.p,{children:"Writing GraphQL schemas manually presents several challenges that can complicate and slow down the development process:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex API Responses"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Large and Detailed Responses"}),": APIs often return extensive and intricate data, making it laborious to map these responses accurately to GraphQL types."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Nested Structures"}),": Dealing with deeply nested JSON objects requires careful handling to ensure all relationships and data hierarchies are correctly represented in the schema."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Consistency"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Missing Properties"}),": APIs can have inconsistent data where some items might lack certain properties, necessitating meticulous examination to define accurate types and optional fields."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic Data"}),": Handling APIs with dynamic data fields adds another layer of complexity, requiring flexible and robust schema definitions to accommodate various data shapes."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Migration Efforts"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Manual Workload"}),": Converting existing REST APIs or gRPC to GraphQL involves substantial manual effort, such as","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type and Schema Writing"}),": Each endpoint must be meticulously mapped to corresponding GraphQL types and queries."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Merging"}),": Identifying types that are similar in configuration and merging them into single type is tedious and time taking task and prone to errors."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Duplicate Type"}),": Identifying and eliminating duplicate in the entire configuration is challenging especially for large scheams, to ensure a clean schema."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Naming"}),": Inferring and naming types manually, which requires a deep understanding of the underlying data structures and their relationships."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error-Prone Process"}),": The manual creation of schemas increases the likelihood of errors, leading to potential issues in data fetching and integration."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These challenges highlight the need for automated tools, which streamline the process of generating GraphQL schemas, ensuring accuracy and efficiency while reducing the manual workload and error potential."}),"\n",(0,s.jsxs)(n.p,{children:["For more insights on why manual GraphQL schema writing is becoming obsolete, you can read this ",(0,s.jsx)(n.a,{href:"https://blog.tailcall.run/writing-a-graphql-backend-by-hand-is-long-gone",children:"blog post by Tailcall"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,s.jsx)("hr",{}),"\n",(0,s.jsx)(n.h3,{id:"effortless-rest-integration",children:"Effortless REST Integration"}),"\n",(0,s.jsx)(n.p,{children:"Tailcall simplifies GraphQL schema generation from REST APIs, supporting various request types and scenarios. Let's understand this through various examples."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Simple GET Request:"})," In the following example, we demonstrate how to generate a GraphQL schema from ",(0,s.jsx)(n.code,{children:"https://jsonplaceholder.typicode.com/posts"})," endpoint."]}),"\n",(0,s.jsx)(n.p,{children:"This configuration allows Tailcall to fetch data from the specified endpoint and generate a GraphQL schema and save it to output path provided in configuration."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "inputs": [\n    {\n      "curl": {\n        "src": "https://jsonplaceholder.typicode.com/posts",\n        "fieldName": "posts",\n        "headers": {\n          "Accept": "application/json",\n          "secretToken": "{{.env.TOKEN}}"\n        }\n      }\n    }\n  ],\n  "preset": {\n    "mergeType": 1.0\n  },\n  "output": {\n    "path": "./jsonplaceholder.graphql",\n    "format": "graphQL"\n  },\n  "schema": {\n    "query": "Query"\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:'inputs:\n  - curl:\n      src: "https://jsonplaceholder.typicode.com/posts"\n      fieldName: "posts"\n      headers:\n        Accept: "application/json"\n        secretToken: "{{.env.TOKEN}}"\npreset:\n  mergeType: 1.0\noutput:\n  path: "./jsonplaceholder.graphql"\n  format: "graphQL"\nschema:\n  query: "Query"\n'})})})]}),"\n",(0,s.jsx)(n.p,{children:"Let's understand the above configuration file."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Defines the API endpoints that the configuration interacts with. Each input specifies:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"src"}),": Specifies the endpoint URL (",(0,s.jsx)(n.code,{children:"https://jsonplaceholder.typicode.com/posts"}),") in this example."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"fieldName"}),": A unique name that should be used as the field name, which is then used in the operation type. In the example above, it's set to ",(0,s.jsx)(n.code,{children:"posts"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"important",children:(0,s.jsxs)(n.p,{children:["Ensure that each ",(0,s.jsx)(n.strong,{children:"field name"})," is unique across the entire configuration to prevent overwriting previous definitions."]})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"headers"}),": Optional section for specifying HTTP headers required for the API request."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Never store sensitive information like access tokens directly in configuration files. Leverage templates to securely reference secrets from ",(0,s.jsx)(n.a,{href:"/docs/graphql-environment-variables",children:"environment variables"}),"."]})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Preset"}),": We've applied only one tuning parameter for the configuration. let's understand it in short."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We've set ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#mergetype",children:"mergeType"})," to ",(0,s.jsx)(n.code,{children:"1.0"}),", which basically tells config generator to merge any two GraphQL types that are exactly similar."]}),"\n",(0,s.jsxs)(n.p,{children:["if you're interested in understanding preset's in detail head over to ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#understanding-presets",children:"preset"})," section."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Specifies where and in what format the output data should be saved."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"path"}),": Defines the output file path (in above example, it's ",(0,s.jsx)(n.code,{children:"./jsonplaceholder.graphql"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"format"}),": Specifies the output format as GraphQL (in above example, it's ",(0,s.jsx)(n.code,{children:"graphQL"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To generate the GraphQL configuration run following command"}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON Config Format",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"bash     tailcall gen ./config.json     "})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML Config Format",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"bash     tailcall gen ./config.yml     "})})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Schema"}),": Specifies the name of the Query operation type, which is ",(0,s.jsx)(n.code,{children:"Query"})," in this example."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'showLineNumbers title="Generated GraphQL Configuration"',children:'schema\n  @server\n  @upstream(\n    baseURL: "https://jsonplaceholder.typicode.com"\n  ) {\n  query: Query\n}\n\ntype Post {\n  body: String\n  id: Int\n  title: String\n  userId: Int\n}\n\ntype Query {\n  posts: [Post] @http(path: "/posts")\n}\n'})}),"\n",(0,s.jsx)("hr",{}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Simple Post Request"})}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, we demonstrate how to generate a GraphQL schema from ",(0,s.jsx)(n.code,{children:"https://jsonplaceholder.typicode.com/posts"})," endpoint which requires some request body in order to produce the response."]}),"\n",(0,s.jsx)(n.p,{children:"This configuration allows Tailcall to make a POST request to the upstream API and retrieve the response to generate a GraphQL schema, which is then saved to the output path specified in the configuration."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "inputs":[\n    {\n      "curl": {\n        "src": "https://jsonplaceholder.typicode.com/posts",\n        "method": "POST",\n        "body": {\n          "title": "Tailcall - Modern GraphQL Runtime",\n          "body": "Tailcall - Modern GraphQL Runtime",\n          "userId": 1\n        },\n        "headers": {\n          "Content-Type": "application/json",\n          "Accept": "application/json"\n        },\n        "isMutation": true,\n        "fieldName": "createPost"\n      }\n    }\n  ],\n   "preset": {\n    "mergeType": 1.0\n  },\n  "output":{\n    "path":"./jsonplaceholder.graphql",\n    "format":"graphQL"\n  },\n  "schema":{\n    "mutation":"Mutation"\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:'inputs:\n  - curl:\n      src: "https://jsonplaceholder.typicode.com/posts/1"\n      fieldName: "createPost"\n      method: "POST"\n      isMutation: true\n      body:\n        title: "Tailcall - Modern GraphQL Runtime"\n        body: "Tailcall - Modern GraphQL Runtime"\n        userId: 1\n      headers:\n        Accept: "application/json"\n        Content-Type: "application/json"\npreset:\n  mergeType: 1.0\noutput:\n  path: "./jsonplaceholder.graphql"\n  format: "graphQL"\nschema:\n  query: "Query"        \n'})})})]}),"\n",(0,s.jsx)(n.p,{children:"Let's understand the above configuration file."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Defines the API endpoints that the configuration interacts with. Each input specifies:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"src"}),": Specifies the endpoint URL (",(0,s.jsx)(n.a,{href:"https://jsonplaceholder.typicode.com/posts",children:"https://jsonplaceholder.typicode.com/posts"})," in this example)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"fieldName"}),": A unique name that should be used as the field name, which is then used in the operation type. In the example above, it's set to ",(0,s.jsx)(n.code,{children:"createPost"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"important",children:(0,s.jsxs)(n.p,{children:["Ensure that each ",(0,s.jsx)(n.strong,{children:"field name"})," is unique across the entire configuration to prevent overwriting previous definitions."]})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"headers"}),": Users can specify the required headers to make the HTTP request in the headers section."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Never store sensitive information like access tokens directly in configuration files. Leverage templates to securely reference secrets from ",(0,s.jsx)(n.a,{href:"/docs/graphql-environment-variables",children:"environment variables"}),"."]})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"body"}),": This property allows you to specify the request body for methods like POST or PUT. If the endpoint requires a payload, include it here."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"method"}),": Specify the HTTP method for the request (e.g. GET, POST, PUT, DEL). If not provided, the default method is ",(0,s.jsx)(n.code,{children:"GET"}),". in above example, it's set to ",(0,s.jsx)(n.code,{children:"POST"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"isMutation"}),": This flag indicates whether the request should be treated as a GraphQL Mutation. Set ",(0,s.jsx)(n.code,{children:"isMutation"})," to ",(0,s.jsx)(n.code,{children:"true"})," to configure the request as a ",(0,s.jsx)(n.code,{children:"Mutation"}),". If not specified or set to false, the request will be treated as a ",(0,s.jsx)(n.code,{children:"Query by default"}),". in above example it's set to true."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Preset"}),": We've applied only one tuning parameter for the configuration. let's understand it in short."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We've set ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#mergetype",children:"mergeType"})," to ",(0,s.jsx)(n.code,{children:"1.0"}),", which basically tells config generator to merge any two GraphQL types that are exactly similar."]}),"\n",(0,s.jsxs)(n.p,{children:["if you're interested in understanding preset's in detail head over to ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#understanding-presets",children:"preset"})," section."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Specifies where and in what format the output data should be saved."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"path"}),": Defines the output file path (in above example, it's ",(0,s.jsx)(n.code,{children:"./jsonplaceholder.graphql"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"format"}),": Specifies the output format as GraphQL (in above example, it's ",(0,s.jsx)(n.code,{children:"graphQL"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To generate the GraphQL configuration run following command"}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"tailcall gen ./config.json\n"})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"tailcall gen ./config.yml\n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Schema"}),": Specifies the operation type. In this example, it's a ",(0,s.jsx)(n.code,{children:"Mutation"})," operation with the name ",(0,s.jsx)(n.code,{children:"Mutation"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'showLineNumbers title="Generated GraphQL Configuration"',children:'schema @server @upstream {\n  mutation: Mutation\n}\n\ninput PostInput {\n  body: String\n  title: String\n  userId: Int\n}\n\ntype Mutation {\n  createPost(createPostInput: PostInput): Post\n    @http(\n      baseURL: "https://jsonplaceholder.typicode.com"\n      body: "{{.args.createPostInput}}"\n      method: "POST"\n      path: "/posts"\n    )\n}\n\ntype Post {\n  body: String\n  id: Int\n  title: String\n  userId: Int\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["This flexible configuration approach allows you to adapt Tailcall for various HTTP methods by modifying key sections like ",(0,s.jsx)(n.code,{children:"method"}),", ",(0,s.jsx)(n.code,{children:"body"}),", ",(0,s.jsx)(n.code,{children:"isMutation"})," and ",(0,s.jsx)(n.code,{children:"headers"}),". Tailcall will handle generating the appropriate GraphQL schema based on the provided API interactions."]})}),"\n",(0,s.jsx)(n.h3,{id:"effortless-grpc-integration",children:"Effortless gRPC Integration"}),"\n",(0,s.jsx)(n.p,{children:"Tailcall simplifies the process of generating GraphQL schemas from gRPC. By specifying the proto file path, Tailcall parses it and generates the corresponding GraphQL types and queries within minutes."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"gRPC Integration"}),": In the following example, we demonstrate how to generate a GraphQL schema from a ",(0,s.jsx)(n.code,{children:"news.proto"})," file."]}),"\n",(0,s.jsx)(n.p,{children:"This configuration allows Tailcall to parse the proto file, generate a GraphQL schema and save it to the output path provided in the configuration."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "inputs": [\n    {\n      "proto": {\n        "src": "./news.proto"\n      }\n    }\n  ],\n  "preset": {\n    "mergeType": 1.0\n  },\n  "output": {\n    "path": "./jsonplaceholder.graphql",\n    "format": "graphQL"\n  },\n  "schema": {\n    "query": "Query"\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:'  inputs:\n    - proto:\n      src: "./news.proto"\n  preset:\n    mergeType: 1.0\n  output:\n    path: "./jsonplaceholder.graphql"\n    format: "graphQL"\n  schema:\n    query: "Query"\n'})})})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's understand the above configuration file."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Proto"}),": Defines the path to the proto file that the configuration interacts with."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"src"}),": Specifies the path to the proto file (",(0,s.jsx)(n.code,{children:"./news.proto"})," in this example)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Preset"}),": We've applied only one tuning parameter for the configuration. let's understand it in short."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We've set ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#mergetype",children:"mergeType"})," to ",(0,s.jsx)(n.code,{children:"1.0"}),", which basically tells config generator to merge any two GraphQL types that are exactly similar."]}),"\n",(0,s.jsxs)(n.p,{children:["if you're interested in understanding preset's in detail head over to ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#understanding-presets",children:"preset"})," section."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Specifies where and in what format the output data should be saved."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"path"}),": Defines the output file path (in above example, it's ",(0,s.jsx)(n.code,{children:"./jsonplaceholder.graphql"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"format"}),": Specifies the output format as GraphQL (in above example, it's ",(0,s.jsx)(n.code,{children:"graphQL"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Schema"}),": Specifies the name of the Query operation type, which is ",(0,s.jsx)(n.code,{children:"Query"})," in this example."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'showLineNumbers title="Generated GraphQL Configuration"',children:'schema @link(src: "./news.proto", type: Protobuf) @server {\n  query: Query\n}\n\ntype News @tag(id: "news.News") {\n  id: Int\n  title: String\n  content: String\n  author: String\n}\n\ntype Query {\n  news: [News] @grpc(method: "news.NewsService.GetNews")\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["for more insights on how gPRC works with GraphQL, you can read this ",(0,s.jsx)(n.a,{href:"/docs/graphql-grpc-tailcall",children:"GraphQL over gRPC"})," article."]}),"\n",(0,s.jsx)(n.h3,{id:"hybrid-integration-rest--grpc",children:"Hybrid Integration (REST + gRPC)"}),"\n",(0,s.jsx)(n.p,{children:"The Configuration Generator with Tailcall supports a hybrid integration of REST and gRPC. This feature allows you to leverage the strengths of both REST APIs and gRPC to create a unified GraphQL schema. By integrating both sources, you can ensure that your GraphQL schema is comprehensive and up-to-date with your existing APIs and data definitions."}),"\n",(0,s.jsx)(n.h4,{id:"example-configuration",children:"Example Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Here is an example configuration that demonstrates how to set up a hybrid integration using a REST and gRPC:"}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "inputs": [\n    {\n      "curl": {\n        "src": "https://jsonplaceholder.typicode.com/posts",\n        "fieldName": "posts"\n      }\n    },\n    {\n      "proto": {\n        "src": "./news.proto"\n      }\n    }\n  ],\n  "preset": {\n    "mergeType": 1.0\n  },\n  "output": {\n    "path": "./output.graphql",\n    "format": "graphQL"\n  },\n  "schema": {\n    "query": "Query"\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:"showLineNumbers",children:'inputs:\n  - curl:\n      src: "https://jsonplaceholder.typicode.com/posts"\n      fieldName: "posts"\n  - proto:\n      src: "./news.proto"\npreset:\n  mergeType: 1.0\noutput:\n  path: "./output.graphql"\n  format: "graphQL"\nschema:\n  query: "Query"\n'})})})]}),"\n",(0,s.jsx)(n.p,{children:"Let's understand the above configuration file."}),"\n",(0,s.jsx)(n.h4,{id:"inputs",children:"Inputs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"curl"})," - section where we can specify the REST endpoint.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"src:"})," The URL of the REST API endpoint."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"fieldName:"})," The field name to use in the GraphQL schema for the REST data."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"proto"})," - section where we can specify the Proto File.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"src:"})," The path to the Proto file."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Preset"}),": We've applied only one tuning parameter for the configuration. let's understand it in short."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We've set ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#mergetype",children:"mergeType"})," to ",(0,s.jsx)(n.code,{children:"1.0"}),", which basically tells config generator to merge any two GraphQL types that are exactly similar."]}),"\n",(0,s.jsxs)(n.p,{children:["if you're interested in understanding preset's in detail head over to ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#understanding-presets",children:"preset"})," section."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": Specifies where and in what format the output data should be saved."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"path"}),": Defines the output file path (in above example, it's ",(0,s.jsx)(n.code,{children:"./jsonplaceholder.graphql"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"format"}),": Specifies the output format as GraphQL (in above example, it's ",(0,s.jsx)(n.code,{children:"graphQL"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To generate the GraphQL configuration run following command"}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"tailcall gen ./config.json\n"})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML Config Format",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"tailcall gen ./config.yml\n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Schema"}),": Specifies the name of the Query operation type, which is ",(0,s.jsx)(n.code,{children:"Query"})," in this example."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'schema\n  @link(src: "./news.proto", type: Protobuf)\n  @upstream(baseURL: "https://jsonplaceholder.typicode.com")\n  @server {\n  query: Query\n}\n\ntype News @tag(id: "news.News") {\n  id: Int\n  title: String\n  content: String\n  author: String\n}\n\ntype Post {\n  body: String\n  id: Int\n  title: String\n  userId: Int\n}\n\ntype Query {\n  posts: [Post] @http(path: "/posts")\n  news: [News] @grpc(method: "news.NewsService.GetNews")\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"understanding-presets",children:"Understanding Presets"}),"\n",(0,s.jsx)(n.p,{children:"This section is optional and can be used to generate a more optimized configuration by applying various transformers that improve the config generation process, such as automatically inferring meaningful names of the types, merging duplicate types, removing unused types, and more. If you find that the generated GraphQL configuration is sufficient for your needs, you can skip this section."}),"\n",(0,s.jsxs)(n.p,{children:["The config generator provides a set of tuning parameters that can make the generated configurations more readable by reducing duplication and making configuration more readable. This can be configured using the ",(0,s.jsx)(n.code,{children:"preset"})," section present in configuration."]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n   "preset": {\n    "mergeType": 0.8,\n    "consolidateURL": 0.8,\n    "treeShake": true,\n    "unwrapSingleFieldTypes": true,\n    "inferTypeNames": true,\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:"preset:\n  mergeType: 0.8\n  consolidateURL: 0.8\n  treeShake: true\n  unwrapSingleFieldTypes: true\n  inferTypeNames: true\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:"Let's understand how each of the parameter works."}),"\n",(0,s.jsx)(n.h3,{id:"mergetype",children:"mergeType"}),"\n",(0,s.jsxs)(n.p,{children:["This setting merges types in the configuration that satisfy the threshold criteria. It takes a threshold value between ",(0,s.jsx)(n.code,{children:"0.0"})," and ",(0,s.jsx)(n.code,{children:"1.0"})," to determine if two types should be merged or not. The default is ",(0,s.jsx)(n.code,{children:"1.0"}),". MergeType also supports union types as well as interface types but merging of these types will happen only when they match exactly."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example 1"}),": following types ",(0,s.jsx)(n.code,{children:"T1"})," and ",(0,s.jsx)(n.code,{children:"T2"})," are exactly similar, and with a threshold value of ",(0,s.jsx)(n.code,{children:"1.0"}),", they can be merged into a single type called ",(0,s.jsx)(n.code,{children:"M1"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'{14} showLineNumbers title="Merging type T1 and T2 into M1"',children:"# BEFORE\ntype T1 {\n    id: ID\n    firstName: String\n    lastName: String\n}\n\ntype T2 {\n    id: ID\n    firstName: String\n    lastName: String\n}\n\n# AFTER: T1 and T2 are merged into M1.\ntype M1 {\n    id: ID\n    firstName: String\n    lastName: String\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example 2"}),": following types ",(0,s.jsx)(n.code,{children:"T1"})," and ",(0,s.jsx)(n.code,{children:"T2"})," are similar with a threshold value of ",(0,s.jsx)(n.code,{children:"0.5"}),", they can be merged into a single type called ",(0,s.jsx)(n.code,{children:"M1"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'{14} showLineNumbers title="Merging type T1 and T2 into M1"',children:"# BEFORE\ntype T1 {\n    id: ID\n    firstName: String\n    age: Int\n}\n\ntype T2 {\n    id: ID\n    firstName: String\n    lastName: String\n}\n\n# AFTER: T1 and T2 are merged into M1.\ntype M1 {\n    id: ID\n    firstName: String\n    lastName: String\n    age: Int\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example 3"}),": following types ",(0,s.jsx)(n.code,{children:"T1"})," and ",(0,s.jsx)(n.code,{children:"T2"})," are similar with a threshold value of ",(0,s.jsx)(n.code,{children:"0.5"})," but we can't merge them as they have same field name but different types:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"{5,11} showLineNumbers title=\"Can't Merge type T1 and T2 as they've same field name but different type\"",children:"# BEFORE\ntype T1 {\n    id: ID\n    firstName: String\n    age: Int\n}\n\ntype T2 {\n    id: ID\n    firstName: String\n    age: Float\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example 4"}),": following types ",(0,s.jsx)(n.code,{children:"Foo"})," and ",(0,s.jsx)(n.code,{children:"Bar"})," will be merged into type ",(0,s.jsx)(n.code,{children:"M1"})," as they match exactly and same change will reflected in union type ",(0,s.jsx)(n.code,{children:"FooBar"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'{24} showLineNumbers title="Merging type Foo and Bar into M1"',children:"# BEFORE\ntype Foo {\n    id: ID\n    firstName: String\n    age: Int\n}\n\ntype Bar {\n    id: ID\n    firstName: String\n    age: Int\n}\n\nunion FooBar = Foo | Bar\n\n# After merging\n\ntype M1 {\n    id: ID\n    firstName: String\n    age: Int\n}\n\nunion FooBar = M1\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example 5"}),": following types ",(0,s.jsx)(n.code,{children:"Foo"})," and ",(0,s.jsx)(n.code,{children:"Bar"})," won't be merged into type ",(0,s.jsx)(n.code,{children:"M1"})," as they don't match exactly."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"{5,11} showLineNumbers title=\"Can't Merge type T1 and T2 as they've same field name but different type\"",children:"# BEFORE\ntype Foo {\n    id: ID\n    firstName: String\n    age: Float\n}\n\ntype Bar {\n    id: ID\n    firstName: String\n    age: Int\n}\n\nunion FooBar = Foo | Bar\n"})}),"\n",(0,s.jsx)("hr",{}),"\n",(0,s.jsx)(n.h3,{id:"consolidateurl",children:"consolidateURL"}),"\n",(0,s.jsxs)(n.p,{children:["The setting identifies the most common base URL among multiple REST endpoints and uses this URL in the ",(0,s.jsx)(n.a,{href:"/docs/tailcall-dsl-graphql-custom-directives#upstream-directive",children:"upstream"})," directive. It takes a threshold value between 0.0 and 1.0 to determine the most common endpoint. The default is ",(0,s.jsx)(n.code,{children:"0.5"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if the ",(0,s.jsx)(n.code,{children:"Query"})," type has three base URLs, using the ",(0,s.jsx)(n.code,{children:"consolidateURL"})," setting with a ",(0,s.jsx)(n.code,{children:"0.5"})," threshold will pick the base URL that is used in more than 50% of the ",(0,s.jsx)(n.a,{href:"/docs/tailcall-dsl-graphql-custom-directives#http-directive",children:"http"})," directives, ",(0,s.jsx)(n.code,{children:"http://jsonplaceholder.typicode.com"}),", and add it to the upstream, cleaning the base URLs from the ",(0,s.jsx)(n.code,{children:"Query"})," type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'schema\n  @server(hostname: "0.0.0.0", port: 8000)\n  @upstream(httpCache: 42) {\n  query: Query\n}\n\ntype Query {\n  post(id: Int!): Post\n    @http(\n      baseURL: "http://jsonplaceholder.typicode.com"\n      path: "/posts/{{.args.id}}"\n    )\n  posts: [Post]\n    @http(\n      baseURL: "http://jsonplaceholder.typicode.com"\n      path: "/posts"\n    )\n  user(id: Int!): User\n    @http(\n      baseURL: "http://jsonplaceholder.typicode.com"\n      path: "/users/{{.args.id}}"\n    )\n  users: [User]\n    @http(\n      baseURL: "http://jsonplaceholder-1.typicode.com"\n      path: "/users"\n    )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["After enabling the ",(0,s.jsx)(n.code,{children:"consolidateURL"})," setting:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'schema\n  @server(hostname: "0.0.0.0", port: 8000)\n  @upstream(\n    baseURL: "http://jsonplaceholder.typicode.com"\n    httpCache: 42\n  ) {\n  query: Query\n}\n\ntype Query {\n  post(id: Int!): Post @http(path: "/posts/{{.args.id}}")\n  posts: [Post] @http(path: "/posts")\n  user(id: Int!): User @http(path: "/users/{{.args.id}}")\n  users: [User]\n    @http(\n      baseURL: "http://jsonplaceholder-1.typicode.com"\n      path: "/users"\n    )\n}\n'})}),"\n",(0,s.jsx)("hr",{}),"\n",(0,s.jsx)(n.h3,{id:"unwrapsinglefieldtypes",children:"unwrapSingleFieldTypes"}),"\n",(0,s.jsx)(n.p,{children:"This setting instructs Tailcall to flatten out types with single field."}),"\n",(0,s.jsx)(n.p,{children:"for example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:"type Query {\n  foo: Foo\n}\n\n# Type with only one field\ntype Foo {\n  bar: Bar\n}\n\n# Type with only one field\ntype Bar {\n  a: Int\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After setting ",(0,s.jsx)(n.code,{children:"unwrapSingleFieldTypes"})," to true:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:"type Query {\n  foo: Int\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This helps in flattening out types into single field."}),"\n",(0,s.jsx)("hr",{}),"\n",(0,s.jsx)(n.h3,{id:"treeshake",children:"treeShake"}),"\n",(0,s.jsx)(n.p,{children:"This setting removes unused types from the configuration. When enabled, any type that is defined in the configuration but not referenced anywhere else (e.g., as a field type, union member, or interface implementation) will be removed. This helps to keep the configuration clean and free from unnecessary definitions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'showLineNumbers title="Before applying treeShake, the configuration might look like this."',children:"type Query {\n  foo: Foo\n}\n\ntype Foo {\n  bar: Bar\n}\n\n# Type not used anywhere else\ntype UnusedType {\n  baz: String\n}\n\ntype Bar {\n  a: Int\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'showLineNumbers title="After enabling treeShake, the UnusedType will be removed."',children:"type Query {\n  foo: Foo\n}\n\ntype Foo {\n  bar: Bar\n}\n\ntype Bar {\n  a: Int\n}\n"})}),"\n",(0,s.jsx)("hr",{}),"\n",(0,s.jsx)(n.h3,{id:"infertypenames",children:"inferTypeNames"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"inferTypeNames"})," setting aims to enhance type naming consistency and readability by suggesting meaningful type names derived from its usage and shape."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Heuristic Algorithm"})}),"\n",(0,s.jsx)(n.p,{children:"This is the default algorithm used to infer the name of the types in the configuration."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Generates Type Names"}),": Creates type names from field names using pluralization and other heuristics."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Updates Configuration"}),": Replaces existing type names with the inferred names and updates all references."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Before enabling inferTypeNames setting"',children:'type T1 {\n  id: ID\n  name: String\n  email: String\n  post: [T2]\n}\n\ntype T2 {\n  id: ID\n  title: String\n  body: String\n}\n\ntype Query {\n  users: [T1] @http(path: "/users")\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"User"}),": Derived from T1, since T1 is linked to user data through the users field in the Query type. The new name User clearly indicates the type represents user information."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Post"}),": Derived from T2, since T2 is linked to post data through the post field within User. The new name Post clearly indicates the type represents post information."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="After enabling inferTypeNames setting"',children:'type User {\n  id: ID\n  name: String\n  email: String\n  post: [Post]\n}\n\ntype Post {\n  id: ID\n  title: String\n  body: String\n}\n\ntype Query {\n  user: User @http(path: "/users")\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"By leveraging field names to derive type names, the schema becomes more intuitive and aligned with the data it represents, making it easier to understand and maintain."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Additional Considerations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Priority Handling:"})," Types directly associated with root operations are given higher priority during inference. For example, if ",(0,s.jsx)(n.code,{children:"T2"})," were associated with a root query or mutation type, it might have a higher priority for inference compared to other types."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pluralization Rules:"})," The inferred type names are converted to singular form to align with typical GraphQL naming conventions. For instance, a type derived from a plural field name like ",(0,s.jsx)(n.code,{children:"comments"})," would be singularized to ",(0,s.jsx)(n.code,{children:"Comment"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"llm-powered-inference",children:"LLM Powered Inference"}),"\n",(0,s.jsx)(n.p,{children:"This is a more advanced completely opt-in feature. Sometimes it's not possible to infer names correctly based on usage, or a name is not available because its been used already. In such scenarios we leverage LLMs that understand relationships between fields, their schema and other meta information to infer type names. To allow Tailcall to connect to LLMs, you need to provide the API key in the configuration file."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "llm": {\n    "model": "gpt-4o",\n    "secret": "{{env.LLM_API_KEY}}"\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:"showLineNumbers",children:'llm:\n  model: "gpt-4o"\n  secret: "{{env.LLM_API_KEY}}"\n'})})})]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Checkout our ",(0,s.jsx)(n.a,{href:"/docs/llm-integration",children:"LLM"})," section to get a list of all the LLM models that Tailcall supports."]})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.p,{children:"When setting up your configuration file for GraphQL generation with Tailcall, consider these key parameters to optimize and customize your setup:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#mergetype",children:"Merge Type"})}),":\nControls the merging of similar GraphQL types to reduce duplication. Adjust the threshold (0.0 to 1.0) based on how strictly you want types to match for merging.\nthe closer the number to 1.0, you get the best type inference in graphQL playground. Recommended threshold is anything above ",(0,s.jsx)(n.code,{children:"0.9"}),"."]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "preset": {\n      "mergeType": 0.9\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:"preset:\n    mergeType: 0.9\n"})})})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#consolidateurl",children:"Consolidate URL"})}),": Identifies the most common base URL among multiple REST endpoints and uses it in the ",(0,s.jsx)(n.a,{href:"/docs/tailcall-dsl-graphql-custom-directives#upstream-directive",children:"@upstream"})," directive. Set a threshold (0.0 to 1.0) to determine when to consolidate URLs. Recommended threshold is anything above ",(0,s.jsx)(n.code,{children:"0.5"}),"."]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "preset": {\n    "consolidateURL": 0.5\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:"preset:\n    consolidateURL: 0.5\n"})})})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Headers"}),": Never store sensitive information like access tokens directly in configuration files. Leverage templates to securely reference secrets from ",(0,s.jsx)(n.a,{href:"/docs/graphql-environment-variables",children:"environment variables"}),"."]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "headers": {\n    "secretToken": "{{.env.TOKEN}}"\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:'headers:\n    secretToken: "{{.env.TOKEN}}"\n'})})})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"faqs",children:"FAQ's"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Q. Can I use environment variables in my configuration?"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Answer:"})," Yes, you can use ",(0,s.jsx)(n.a,{href:"/docs/graphql-environment-variables",children:"environment variables"})," to securely reference sensitive information like access tokens. Here is an example:"]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "curl": {\n    "src": "https://jsonplaceholder.typicode.com/posts/1",\n    "fieldName": "post",\n    "headers": {\n      "secretToken": "{{.env.TOKEN}}"\n    }\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:'curl:\n  src: "https://jsonplaceholder.typicode.com/posts/1"\n  fieldName: "post"\n  headers:\n      secretToken: "{{.env.TOKEN}}"\n'})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Q. How do I merge similar types in the configuration?"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Answer:"})," Adjust the ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#mergetype",children:"mergeType"})," parameter in the preset section to control the merging of similar types. A threshold value between 0.0 and 1.0 determines if two types should be merged or not. if you to understand this in detail then please head over to ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#understanding-presets",children:"preset"})," section. Here is an example:"]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "preset": {\n    "mergeType": 0.9\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:"preset:\n    mergeType: 0.9\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Q. What if I have multiple REST endpoints with different base URLs?"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Answer:"})," Use the ",(0,s.jsx)(n.a,{href:"/docs/graphql-configuration-generation-with-tailcall#consolidateurl",children:"consolidateURL"})," parameter to identify the most common base URL among multiple REST endpoints and it will automatically select the most common base url and add it to the ",(0,s.jsx)(n.a,{href:"/docs/tailcall-dsl-graphql-custom-directives#upstream-directive",children:"@upstream"})," directive. Here is an example:"]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "preset": {\n    "consolidateURL": 0.5\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:"preset:\n    consolidateURL: 0.5\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Q. Can I specify multiple input sources in a single configuration?"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Answer:"})," Yes, you can specify multiple input sources, such as different REST endpoints or Proto files, in a single configuration. Here is an example:"]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(a.A,{value:"json",label:"JSON",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"showLineNumbers",children:'{\n  "inputs": [\n    {\n      "curl": {\n        "src": "https://jsonplaceholder.typicode.com/posts",\n        "fieldName": "posts"\n      }\n    },\n    {\n      "proto": {\n        "src": "./news.proto"\n      }\n    }\n  ],\n  "schema": {\n    "query": "Query"\n  }\n}\n'})})}),(0,s.jsx)(a.A,{value:"yml",label:"YML",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",metastring:"showLineNumbers",children:'inputs:\n  - curl:\n      src: "https://jsonplaceholder.typicode.com/posts"\n      fieldName: "posts"\n  - proto:\n      src: "./news.proto"\nschema:\n  query: "Query"\n'})})})]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>a});t(96540);var s=t(34164);const r={tabItem:"tabItem_Ymn6"};var i=t(74848);function a(e){let{children:n,hidden:t,className:a}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,a),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>w});var s=t(96540),r=t(34164),i=t(23104),a=t(56347),l=t(205),o=t(57485),c=t(31682),h=t(70679);function d(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:r}}=e;return{value:n,label:t,attributes:s,default:r}}))}(t);return function(e){const n=(0,c.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function u(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:t}=e;const r=(0,a.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,o.aZ)(i),(0,s.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})}),[i,r])]}function m(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=p(e),[a,o]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!u({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:i}))),[c,d]=g({queryString:t,groupId:r}),[m,j]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,i]=(0,h.Dv)(t);return[r,(0,s.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),x=(()=>{const e=c??m;return u({value:e,tabValues:i})?e:null})();(0,l.A)((()=>{x&&o(x)}),[x]);return{selectedValue:a,selectValue:(0,s.useCallback)((e=>{if(!u({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),j(e)}),[d,j,i]),tabValues:i}}var j=t(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(74848);function y(e){let{className:n,block:t,selectedValue:s,selectValue:a,tabValues:l}=e;const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),h=e=>{const n=e.currentTarget,t=o.indexOf(n),r=l[t].value;r!==s&&(c(n),a(r))},d=e=>{let n=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:l.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>o.push(e),onKeyDown:d,onClick:h,...i,className:(0,r.A)("tabs__item",x.tabItem,i?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function b(e){let{lazy:n,children:t,selectedValue:r}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function v(e){const n=m(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",x.tabList),children:[(0,f.jsx)(y,{...n,...e}),(0,f.jsx)(b,{...n,...e})]})}function w(e){const n=(0,j.A)();return(0,f.jsx)(v,{...e,children:d(e.children)},String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var s=t(96540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);