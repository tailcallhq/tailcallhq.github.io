"use strict";(self.webpackChunktailcall_run=self.webpackChunktailcall_run||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Introduction","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Quick Start","href":"/docs/intro/quickstart","docId":"intro/quickstart"},{"type":"link","label":"Problem Statement","href":"/docs/","docId":"intro/introduction"},{"type":"link","label":"Architecture","href":"/docs/intro/architecture","docId":"intro/architecture"},{"type":"link","label":"CLI","href":"/docs/intro/cli","docId":"intro/cli"},{"type":"link","label":"Operators","href":"/docs/intro/operators","docId":"intro/operators"},{"type":"link","label":"Context","href":"/docs/intro/context","docId":"intro/context"}]},{"type":"category","label":"Guides","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Installation & Updates","href":"/docs/guides/installation","docId":"guides/installation"},{"type":"link","label":"Tackling N + 1","href":"/docs/guides/n+1","docId":"guides/n+1"}]}]},"docs":{"guides/installation":{"id":"guides/installation","title":"Installation & Updates","description":"To install Tailcall, ensure that your system is equipped with Java 20 or a newer version. You can refer to the setup instructions provided by [sdkman] to correctly install and configure Java on your system.","sidebar":"tutorialSidebar"},"guides/n+1":{"id":"guides/n+1","title":"Tackling N + 1","description":"The N+1 problem is a pervasive and critical issue in application development that occurs when an application ends up issuing a large number of downstream requests, for a single request from upstream. Let\'s understand with an example:","sidebar":"tutorialSidebar"},"intro/architecture":{"id":"intro/architecture","title":"Architecture","description":"What we have built is a open-source API orchestration solution that really thinks about the problem from first principles and achieves far superior results than the legacy solutions that are available today. To understand how it works, here is the technical implementation of our solution.","sidebar":"tutorialSidebar"},"intro/cli":{"id":"intro/cli","title":"CLI","description":"The TailCall CLI (Command Line Interface) is an essential part of the TailCall toolkit. It allows developers to manage and optimize GraphQL configurations directly from the command line. Each command within the CLI is designed to handle a specific aspect of GraphQL composition. Below, you\'ll find a detailed overview of each command, along with its options and usage examples.","sidebar":"tutorialSidebar"},"intro/context":{"id":"intro/context","title":"Context","description":"In any GraphQL framework, including Tailcall, Context is a fundamental mechanism used for data sharing amongst various parts of your application. It is an adaptable object that is made available to every resolver in GraphQL.","sidebar":"tutorialSidebar"},"intro/introduction":{"id":"intro/introduction","title":"Problem Statement","description":"There are two things that are happening in the tech ecosystem nowadays:","sidebar":"tutorialSidebar"},"intro/operators":{"id":"intro/operators","title":"Operators","description":"Tailcall DSL builds on your existing GraphQL knowledge by allowing the addition of some custom operators, termed \'Operators\'. These operators provide powerful compile time guarantees to make sure your API composition is tight and robust. It also automatically generates highly optimized resolver logic for your types.","sidebar":"tutorialSidebar"},"intro/quickstart":{"id":"intro/quickstart","title":"Quick Start","description":"Requirements","sidebar":"tutorialSidebar"}}}')}}]);